<html xmlns="http://www.w3.org/TR/REC-html40" xmlns:html="http://www.w3.org/TR/REC-html40" xmlns:gjdoc="http://www.gnu.org/software/cp-tools/gjdocxml"><head><link href="../../../gjdochtml.css" type="text/css" rel="stylesheet"/><title>PipelineFactory</title></head><body onload="top.document.title=document.title;" class="classdoc"><div class="header"><span class="navi-button">&rArr;&nbsp;<a target="_top" href="../../../index.html">Index&nbsp;(Frames)</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a target="_top" href="../../../index_noframes.html">Index&nbsp;(No&nbsp;Frames)</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a href="package-summary.html">Package</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a href="package-tree.html">Package&nbsp;Tree</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a href="../../../fulltree.html">Full Tree</a></span>&nbsp;
    </div><div class="classdoc-head"><div class="classdoc-head-inner"><b class="classdoc-head-packagename">gnu.xml.pipeline</b><br/><h1 class="classdoc-head-classname">Class PipelineFactory</h1></div></div><pre class="inheritance-tree">java.lang.Object
|
+--gnu.xml.pipeline.PipelineFactory
</pre><p/><hr/><div class="classdoc-prototype">public class <b>PipelineFactory</b><br/>extends java.lang.Object<br/></div><p/><div class="classdoc-class-comment-body"> This provides static factory methods for creating simple event pipelines.
 These pipelines are specified by strings, suitable for passing on
 command lines or embedding in element attributes.  For example, one way
 to write a pipeline that restores namespace syntax, validates (stopping
 the pipeline on validity errors) and then writes valid data to standard
 output is this: <pre>
      nsfix | validate | write ( stdout )</pre><p/> In this syntax, the tokens are always separated by whitespace, and each
 stage of the pipeline may optionally have a parameter (which can be a
 pipeline) in parentheses.  Interior stages are called filters, and the
 rightmost end of a pipeline is called a terminus.

 <p/> Stages are usually implemented by a single class, which may not be
 able to act as both a filter and a terminus; but any terminus can be
 automatically turned into a filter, through use of a <a href="../../../gnu/xml/pipeline/TeeConsumer.html">TeeConsumer</a>.
 The stage identifiers are either class names, or are one of the following
 short identifiers built into this class.  (Most of these identifiers are
 no more than aliases for classes.)  The built-in identifiers include:
<table border="1" cellpadding="3" cellspacing="0"><tr bgcolor="#ccccff" class="TableHeadingColor"><th align="center" width="5%">Stage</th><th align="center" width="9%">Parameter</th><th align="center" width="1%">Terminus</th><th align="center">Description</th></tr><tr valign="top" align="center"><td><a href="../dom/Consumer.html">dom</a></td><td><em>none</em></td><td> yes </td><td align="left"> Applications code can access a DOM Document built
from the input event stream.  When used as a filter, this buffers
data up to an <em>endDocument</em> call, and then uses a DOM parser
to report everything that has been recorded (which can easily be
less than what was reported to it).  </td></tr><tr valign="top" align="center"><td><a href="NSFilter.html">nsfix</a></td><td><em>none</em></td><td>no</td><td align="left">This stage ensures that the XML element and attribute
names in its output use namespace prefixes and declarations correctly.
That is, so that they match the "Namespace plus LocalName" naming data
with which each XML element and attribute is already associated.  </td></tr><tr valign="top" align="center"><td><a href="EventFilter.html">null</a></td><td><em>none</em></td><td>yes</td><td align="left">This stage ignores all input event data.</td></tr><tr valign="top" align="center"><td><a href="CallFilter.html">server</a></td><td><em>required</em><br/> server URL </td><td>no</td><td align="left">Sends its input as XML request to a remote server,
normally a web application server using the HTTP or HTTPS protocols.
The output of this stage is the parsed response from that server.</td></tr><tr valign="top" align="center"><td><a href="TeeConsumer.html">tee</a></td><td><em>required</em><br/> first pipeline</td><td>no</td><td align="left">This sends its events down two paths; its parameter
is a pipeline descriptor for the first path, and the second path
is the output of this stage.</td></tr><tr valign="top" align="center"><td><a href="ValidationConsumer.html">validate</a></td><td><em>none</em></td><td>yes</td><td align="left">This checks for validity errors, and reports them
through its error handler.  The input must include declaration events
and some lexical events.  </td></tr><tr valign="top" align="center"><td><a href="WellFormednessFilter.html">wf</a></td><td><em>none</em></td><td>yes</td><td align="left"> This class provides some basic "well formedness"
tests on the input event stream, and reports a fatal error if any
of them fail.  One example: start/end calls for elements must match.
No SAX parser is permitted to produce malformed output, but other
components can easily do so.</td></tr><tr valign="top" align="center"><td>write</td><td><em>required</em><br/> "stdout", "stderr", or filename</td><td>yes</td><td align="left"> Writes its input to the specified output, as pretty
printed XML text encoded using UTF-8.  Input events must be well
formed and "namespace fixed", else the output won't be XML (or possibly
namespace) conformant.  The symbolic names represent
<em>System.out</em> and <em>System.err</em> respectively; names must
correspond to files which don't yet exist.</td></tr><tr valign="top" align="center"><td>xhtml</td><td><em>required</em><br/> "stdout", "stderr", or filename</td><td>yes</td><td align="left"> Like <em>write</em> (above), except that XHTML rules
are followed.  The XHTML 1.0 Transitional document type is declared,
and only ASCII characters are written (for interoperability).  Other
characters are written as entity or character references; the text is
pretty printed.</td></tr><tr valign="top" align="center"><td><a href="XIncludeFilter.html">xinclude</a></td><td><em>none</em></td><td>no</td><td align="left">This stage handles XInclude processing.
This is like entity inclusion, except that the included content
is declared in-line rather than in the DTD at the beginning of
a document.
</td></tr><tr valign="top" align="center"><td><a href="XsltFilter.html">xslt</a></td><td><em>required</em><br/> XSLT stylesheet URI</td><td>no</td><td align="left">This stage handles XSLT transformation
according to a stylesheet.
The implementation of the transformation may not actually
stream data, although if such an XSLT engine is in use
then that can happen.
</td></tr></table><p/> Note that <a href="../../../gnu/xml/pipeline/EventFilter.html#bind">EventFilter.bind</a> can automatically eliminate
 some filters by setting SAX2 parser features appropriately.  This means
 that you can routinely put filters like "nsfix", "validate", or "wf" at the
 front of a pipeline (for components that need inputs conditioned to match
 that level of correctness), and know that it won't actually be used unless
 it's absolutely necessary.
</div><div class="classdoc-tag-section-header">Author:</div><dl class="classdoc-list"><dt>David Brownell</dt></dl><h1 class="classdoc-header">Method Summary</h1><table class="classdoc-table" width="100%" cellspacing="0" border="1"><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  <a href="../../../gnu/xml/pipeline/EventConsumer.html">EventConsumer</a></p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#createPipeline(String)">createPipeline</a>(<span class="parameter">String&nbsp;description</span>)</p><blockquote class="classdoc-summary-comment"> Creates a simple pipeline according to the description string passed in.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  <a href="../../../gnu/xml/pipeline/EventConsumer.html">EventConsumer</a></p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#createPipeline(String,gnu.xml.pipeline.EventConsumer)">createPipeline</a>(<span class="parameter">String&nbsp;description,</span> <span class="parameter"><a href="../../../gnu/xml/pipeline/EventConsumer.html">EventConsumer</a>&nbsp;next</span>)</p><blockquote class="classdoc-summary-comment"> Extends an existing pipeline by prepending the filter pipeline to the
 specified consumer.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  <a href="../../../gnu/xml/pipeline/EventConsumer.html">EventConsumer</a></p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#createPipeline(String  tokens[],gnu.xml.pipeline.EventConsumer)">createPipeline</a>(<span class="parameter">String  tokens[]&nbsp;,</span> <span class="parameter"><a href="../../../gnu/xml/pipeline/EventConsumer.html">EventConsumer</a>&nbsp;next</span>)</p><blockquote class="classdoc-summary-comment"> Extends an existing pipeline by prepending a pre-tokenized filter
 pipeline to the specified consumer.</blockquote></td></tr></table><h1 class="classdoc-header">Method Details</h1><a name="createPipeline(String,gnu.xml.pipeline.EventConsumer)"/><h3>createPipeline</h3><p class="prototype">public static EventConsumer <b>createPipeline</b>(<span class="parameter">String&nbsp;description,</span> <span class="parameter"><a href="../../../gnu/xml/pipeline/EventConsumer.html">EventConsumer</a>&nbsp;next</span>)</p><div class="classdoc-comment-body"> Extends an existing pipeline by prepending the filter pipeline to the
 specified consumer.  Some pipelines need more customization than can
 be done through this simplified syntax.  When they are set up with
 direct API calls, use this method to merge more complex pipeline
 segments with easily configured ones.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">description</span></dt><dt><span class="prototype-name">next</span></dt></dl><hr/><a name="createPipeline(String)"/><h3>createPipeline</h3><p class="prototype">public static EventConsumer <b>createPipeline</b>(<span class="parameter">String&nbsp;description</span>)</p><div class="classdoc-comment-body"> Creates a simple pipeline according to the description string passed in.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">description</span></dt></dl><hr/><a name="createPipeline(String  tokens[],gnu.xml.pipeline.EventConsumer)"/><h3>createPipeline</h3><p class="prototype">public static EventConsumer <b>createPipeline</b>(<span class="parameter">String  tokens[]&nbsp;,</span> <span class="parameter"><a href="../../../gnu/xml/pipeline/EventConsumer.html">EventConsumer</a>&nbsp;next</span>)</p><div class="classdoc-comment-body"> Extends an existing pipeline by prepending a pre-tokenized filter
 pipeline to the specified consumer.  Tokens are class names (or the
 predefined aliases) left and right parenthesis, and the vertical bar.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name"/></dt><dt><span class="prototype-name">next</span></dt></dl><hr class="footer"/><div class="footer">Generated on
  October 6, 2004
  by <a target="cptoolsinfo" href="http://www.gnu.org/software/cp-tools">GNU Classpath Tools</a> (Gjdoc XmlDoclet 0.6.1).</div></body></html>