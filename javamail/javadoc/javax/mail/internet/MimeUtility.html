<html xmlns="http://www.w3.org/TR/REC-html40" xmlns:html="http://www.w3.org/TR/REC-html40" xmlns:gjdoc="http://www.gnu.org/software/cp-tools/gjdocxml"><head><link href="../../../gjdochtml.css" type="text/css" rel="stylesheet"/><title>MimeUtility</title></head><body onload="top.document.title=document.title;" class="classdoc"><div class="header"><span class="navi-button">&rArr;&nbsp;<a target="_top" href="../../../index.html">Index&nbsp;(Frames)</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a target="_top" href="../../../index_noframes.html">Index&nbsp;(No&nbsp;Frames)</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a href="package-summary.html">Package</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a href="package-tree.html">Package&nbsp;Tree</a></span>&nbsp;|&nbsp;
      <span class="navi-button">&rArr;&nbsp;<a href="../../../fulltree.html">Full Tree</a></span>&nbsp;
    </div><div class="classdoc-head"><div class="classdoc-head-inner"><b class="classdoc-head-packagename">javax.mail.internet</b><br/><h1 class="classdoc-head-classname">Class MimeUtility</h1></div></div><pre class="inheritance-tree">java.lang.Object
|
+--javax.mail.internet.MimeUtility
</pre><p/><hr/><div class="classdoc-prototype">public class <b>MimeUtility</b><br/>extends java.lang.Object<br/></div><p/><div class="classdoc-class-comment-body"> This is a utility class that provides various MIME related functionality.
 <p/>
 There are a set of methods to encode and decode MIME headers as per 
 RFC 2047. A brief description on handling such headers is given below:
 <p/>
 RFC 822 mail headers must contain only US-ASCII characters. Headers that
 contain non US-ASCII characters must be encoded so that they contain only
 US-ASCII characters. Basically, this process involves using either BASE64 
 or QP to encode certain characters. RFC 2047 describes this in detail.
 <p/>
 In Java, Strings contain (16 bit) Unicode characters. ASCII is a subset of
 Unicode (and occupies the range 0 - 127). A String that contains only ASCII
 characters is already mail-safe. If the String contains non US-ASCII
 characters, it must be encoded. An additional complexity in this step is that
 since Unicode is not yet a widely used charset, one might want to first
 charset-encode the String into another charset and then do the
 transfer-encoding.
 <p/>
 Note that to get the actual bytes of a mail-safe String (say, for sending 
 over SMTP), one must do
 <pre>
byte[] bytes = string.getBytes("iso-8859-1")</pre><pre>
 The setHeader() and addHeader() methods on
 MimeMessage and MimeBodyPart assume that the given header values are 
 Unicode strings that contain only US-ASCII characters. Hence the callers 
 of those methods must insure that the values they pass do not contain non 
 US-ASCII characters. The methods in this class help do this.
 
 The getHeader() family of methods on MimeMessage and 
 MimeBodyPart return the raw header value. These might be encoded as per 
 RFC 2047, and if so, must be decoded into Unicode Strings.
 The methods in this class help to do this</pre></div><div class="classdoc-tag-section-header">Author:</div><dl class="classdoc-list"><dt/></dl><h1 class="classdoc-header">Method Summary</h1><table class="classdoc-table" width="100%" cellspacing="0" border="1"><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  InputStream</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#decode(InputStream,String)">decode</a>(<span class="parameter">InputStream&nbsp;is,</span> <span class="parameter">String&nbsp;encoding</span>)</p><blockquote class="classdoc-summary-comment"> Decode the given input stream.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#decodeText(String)">decodeText</a>(<span class="parameter">String&nbsp;etext</span>)</p><blockquote class="classdoc-summary-comment"> Decode "unstructured" headers, that is, headers that are defined as '*text'
 as per RFC 822.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#decodeWord(String)">decodeWord</a>(<span class="parameter">String&nbsp;text</span>)</p><blockquote class="classdoc-summary-comment"> The string is parsed using the rules in RFC 2047 for parsing an
 "encoded-word".</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  OutputStream</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#encode(OutputStream,String)">encode</a>(<span class="parameter">OutputStream&nbsp;os,</span> <span class="parameter">String&nbsp;encoding</span>)</p><blockquote class="classdoc-summary-comment"> Wrap an encoder around the given output stream.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  OutputStream</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#encode(OutputStream,String,String)">encode</a>(<span class="parameter">OutputStream&nbsp;os,</span> <span class="parameter">String&nbsp;encoding,</span> <span class="parameter">String&nbsp;filename</span>)</p><blockquote class="classdoc-summary-comment"> Wrap an encoder around the given output stream.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#encodeText(String)">encodeText</a>(<span class="parameter">String&nbsp;text</span>)</p><blockquote class="classdoc-summary-comment"> Encode a RFC 822 "text" token into mail-safe form as per RFC 2047.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#encodeText(String,String,String)">encodeText</a>(<span class="parameter">String&nbsp;text,</span> <span class="parameter">String&nbsp;charset,</span> <span class="parameter">String&nbsp;encoding</span>)</p><blockquote class="classdoc-summary-comment"> Encode a RFC 822 "text" token into mail-safe form as per RFC 2047.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#encodeWord(String)">encodeWord</a>(<span class="parameter">String&nbsp;text</span>)</p><blockquote class="classdoc-summary-comment"> Encode a RFC 822 "word" token into mail-safe form as per RFC 2047.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#encodeWord(String,String,String)">encodeWord</a>(<span class="parameter">String&nbsp;text,</span> <span class="parameter">String&nbsp;charset,</span> <span class="parameter">String&nbsp;encoding</span>)</p><blockquote class="classdoc-summary-comment"> Encode a RFC 822 "word" token into mail-safe form as per RFC 2047.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#getDefaultJavaCharset()">getDefaultJavaCharset</a>()</p><blockquote class="classdoc-summary-comment"> Get the default charset corresponding to the system's current default
 locale.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#getEncoding(DataSource)">getEncoding</a>(<span class="parameter">DataSource&nbsp;ds</span>)</p><blockquote class="classdoc-summary-comment"> Get the content-transfer-encoding that should be applied to the input
 stream of this datasource, to make it mailsafe.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#getEncoding(DataHandler)">getEncoding</a>(<span class="parameter">DataHandler&nbsp;dh</span>)</p><blockquote class="classdoc-summary-comment"> Same as getEncoding(DataSource) except that instead of reading the data
 from an InputStream it uses the writeTo method to examine the data.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#javaCharset(String)">javaCharset</a>(<span class="parameter">String&nbsp;charset</span>)</p><blockquote class="classdoc-summary-comment"> Convert a MIME charset name into a valid Java charset name.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#mimeCharset(String)">mimeCharset</a>(<span class="parameter">String&nbsp;charset</span>)</p><blockquote class="classdoc-summary-comment"> Convert a java charset into its MIME charset name.</blockquote></td></tr><tr><td class="no-border-r" valign="top" align="right" width="1%"><p class="prototype-type">static  String</p></td><td class="with-border" valign="top" align="left"><p class="prototype"><a href="#quote(String,String)">quote</a>(<span class="parameter">String&nbsp;text,</span> <span class="parameter">String&nbsp;specials</span>)</p><blockquote class="classdoc-summary-comment"> A utility method to quote a word, if the word contains any characters 
 from the specified 'specials' list.</blockquote></td></tr></table><h1 class="classdoc-header">Method Details</h1><a name="decode(InputStream,String)"/><h3>decode</h3><p class="prototype">public static InputStream <b>decode</b>(<span class="parameter">InputStream&nbsp;is,</span> <span class="parameter">String&nbsp;encoding</span>)</p><div class="classdoc-comment-body"> Decode the given input stream.
 The Input stream returned is the decoded input stream.
 All the encodings defined in RFC 2045 are supported here.
 They include "base64", "quoted-printable", "7bit", "8bit", and
 "binary". In addition, "uuencode" is also supported.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">is</span> - input stream</dt><dt><span class="prototype-name">encoding</span> - the encoding of the stream.</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>decoded input stream.</dt></dl><hr/><a name="decodeText(String)"/><h3>decodeText</h3><p class="prototype">public static String <b>decodeText</b>(<span class="parameter">String&nbsp;etext</span>)</p><div class="classdoc-comment-body"> Decode "unstructured" headers, that is, headers that are defined as '*text'
 as per RFC 822.
 <p/>
 The string is decoded using the algorithm specified in RFC 2047, Section
 6.1.1. If the charset-conversion fails for any sequence, an
 UnsupportedEncodingException is thrown. If the String is not an RFC 2047
 style encoded header, it is returned as-is
 <p/>
 Example of usage:
 <pre>
MimePart part = ...
String rawvalue = null;
String  value = null;
try {
if ((rawvalue = part.getHeader("X-mailer")[0]) != null)
value = MimeUtility.decodeText(rawvalue);
} catch (UnsupportedEncodingException e) {
// Don't care
value = rawvalue;
} catch (MessagingException me) { }
return value</pre><pre/></div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">etext</span> - the possibly encoded value</dt></dl><div class="classdoc-tag-section-header">Throws:</div><dl class="classdoc-list"><dt><code/> - if the charset conversion failed.</dt></dl><hr/><a name="decodeWord(String)"/><h3>decodeWord</h3><p class="prototype">public static String <b>decodeWord</b>(<span class="parameter">String&nbsp;text</span>)</p><div class="classdoc-comment-body"> The string is parsed using the rules in RFC 2047 for parsing an
 "encoded-word".
 If the parse fails, a ParseException is thrown. Otherwise, it is 
 transfer-decoded, and then charset-converted into Unicode. If the
 charset-conversion fails, an UnsupportedEncodingException is thrown.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">text</span> - the possibly encoded value</dt></dl><div class="classdoc-tag-section-header">Throws:</div><dl class="classdoc-list"><dt><code><a href="../../../javax/mail/internet/ParseException.html">ParseException</a></code> - if the string is not an encoded-word as per 
RFC 2047.</dt><dt><code/> - if the charset conversion
failed.</dt></dl><hr/><a name="encode(OutputStream,String,String)"/><h3>encode</h3><p class="prototype">public static OutputStream <b>encode</b>(<span class="parameter">OutputStream&nbsp;os,</span> <span class="parameter">String&nbsp;encoding,</span> <span class="parameter">String&nbsp;filename</span>)</p><div class="classdoc-comment-body"> Wrap an encoder around the given output stream.
 All the encodings defined in RFC 2045 are supported here.
 They include "base64", "quoted-printable", "7bit", "8bit" and "binary".
 In addition, "uuencode" is also supported. The <code>filename</code>
 parameter is used with the "uuencode" encoding and is included in the 
 encoded output.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">os</span> - output stream</dt><dt><span class="prototype-name">encoding</span> - the encoding of the stream.</dt><dt><span class="prototype-name">filename</span> - name for the file being encoded (only used with uuencode)</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>output stream that applies the specified encoding.</dt></dl><hr/><a name="encode(OutputStream,String)"/><h3>encode</h3><p class="prototype">public static OutputStream <b>encode</b>(<span class="parameter">OutputStream&nbsp;os,</span> <span class="parameter">String&nbsp;encoding</span>)</p><div class="classdoc-comment-body"> Wrap an encoder around the given output stream.
 All the encodings defined in RFC 2045 are supported here.
 They include "base64", "quoted-printable", "7bit", "8bit" and "binary".
 In addition, "uuencode" is also supported.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">os</span> - output stream</dt><dt><span class="prototype-name">encoding</span> - the encoding of the stream.</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>output stream that applies the specified encoding.</dt></dl><hr/><a name="encodeText(String,String,String)"/><h3>encodeText</h3><p class="prototype">public static String <b>encodeText</b>(<span class="parameter">String&nbsp;text,</span> <span class="parameter">String&nbsp;charset,</span> <span class="parameter">String&nbsp;encoding</span>)</p><div class="classdoc-comment-body"> Encode a RFC 822 "text" token into mail-safe form as per RFC 2047.
 <p/>
 The given Unicode string is examined for non US-ASCII characters. If the
 string contains only US-ASCII characters, it is returned as-is. If the
 string contains non US-ASCII characters, it is first character-encoded
 using the platform's default charset, then transfer-encoded using either
 the B or Q encoding. The resulting bytes are then returned as a Unicode
 string containing only ASCII characters.
 <p/>
 Note that this method should be used to encode only "unstructured" 
 RFC 822 headers.
 <p/></div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">text</span> - the header value</dt><dt><span class="prototype-name">charset</span> - the charset.</dt><dt><span class="prototype-name">encoding</span> - the encoding to be used.</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>Unicode string containing only US-ASCII characters</dt></dl><hr/><a name="encodeText(String)"/><h3>encodeText</h3><p class="prototype">public static String <b>encodeText</b>(<span class="parameter">String&nbsp;text</span>)</p><div class="classdoc-comment-body"> Encode a RFC 822 "text" token into mail-safe form as per RFC 2047.
 <p/>
 The given Unicode string is examined for non US-ASCII characters. If the
 string contains only US-ASCII characters, it is returned as-is. If the
 string contains non US-ASCII characters, it is first character-encoded
 using the platform's default charset, then transfer-encoded using either
 the B or Q encoding. The resulting bytes are then returned as a Unicode
 string containing only ASCII characters.
 <p/>
 Note that this method should be used to encode only "unstructured" 
 RFC 822 headers.
 <p/>
 Example of usage:
 <pre>
MimePart part = ...
String rawvalue = "FooBar Mailer, Japanese version 1.1"
try {
// If we know for sure that rawvalue contains only US-ASCII
// characters, we can skip the encoding part
part.setHeader("X-mailer", MimeUtility.encodeText(rawvalue));
} catch (UnsupportedEncodingException e) {
// encoding failure
} catch (MessagingException me) {
// setHeader() failur</pre></div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">text</span> - unicode string</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>Unicode string containing only US-ASCII characters</dt></dl><hr/><a name="encodeWord(String,String,String)"/><h3>encodeWord</h3><p class="prototype">public static String <b>encodeWord</b>(<span class="parameter">String&nbsp;text,</span> <span class="parameter">String&nbsp;charset,</span> <span class="parameter">String&nbsp;encoding</span>)</p><div class="classdoc-comment-body"> Encode a RFC 822 "word" token into mail-safe form as per RFC 2047.
 <p/>
 The given Unicode string is examined for non US-ASCII characters.
 If the string contains only US-ASCII characters, it is returned as-is.
 If the string contains non US-ASCII characters, it is first 
 character-encoded using the platform's default charset, then 
 transfer-encoded using either the B or Q encoding.
 The resulting bytes are then returned as a Unicode string containing 
 only ASCII characters.
 <p/></div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">text</span> - unicode string</dt><dt><span class="prototype-name">charset</span> - the MIME charset</dt><dt><span class="prototype-name">encoding</span> - the encoding to be used.</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>Unicode string containing only US-ASCII characters</dt></dl><div class="classdoc-tag-section-header">Throws:</div><dl class="classdoc-list"><dt><code/> - if the encoding fails</dt></dl><hr/><a name="encodeWord(String)"/><h3>encodeWord</h3><p class="prototype">public static String <b>encodeWord</b>(<span class="parameter">String&nbsp;text</span>)</p><div class="classdoc-comment-body"> Encode a RFC 822 "word" token into mail-safe form as per RFC 2047.
 <p/>
 The given Unicode string is examined for non US-ASCII characters.
 If the string contains only US-ASCII characters, it is returned as-is.
 If the string contains non US-ASCII characters, it is first 
 character-encoded using the platform's default charset, then 
 transfer-encoded using either the B or Q encoding.
 The resulting bytes are then returned as a Unicode string containing 
 only ASCII characters.
 <p/>
 This method is meant to be used when creating RFC 822 "phrases". The
 InternetAddress class, for example, uses this to encode it's 'phrase'
 component.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">text</span> - unicode string</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>Unicode string containing only US-ASCII characters.</dt></dl><div class="classdoc-tag-section-header">Throws:</div><dl class="classdoc-list"><dt><code/> - if the encoding fails</dt></dl><hr/><a name="getDefaultJavaCharset()"/><h3>getDefaultJavaCharset</h3><p class="prototype">public static String <b>getDefaultJavaCharset</b>()</p><div class="classdoc-comment-body"> Get the default charset corresponding to the system's current default
 locale.
</div><p/><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>the default charset of the system's default locale,
as a Java charset.</dt></dl><hr/><a name="getEncoding(DataHandler)"/><h3>getEncoding</h3><p class="prototype">public static String <b>getEncoding</b>(<span class="parameter">DataHandler&nbsp;dh</span>)</p><div class="classdoc-comment-body"> Same as getEncoding(DataSource) except that instead of reading the data
 from an InputStream it uses the writeTo method to examine the data.
 This is more efficient in the common case of a DataHandler created 
 with an object and a MIME type (for example, a "text/plain" String)
 because all the I/O is done in this thread.
 In the case requiring an InputStream the DataHandler uses a thread,
 a pair of pipe streams, and the writeTo method to produce the data.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">dh</span></dt></dl><hr/><a name="getEncoding(DataSource)"/><h3>getEncoding</h3><p class="prototype">public static String <b>getEncoding</b>(<span class="parameter">DataSource&nbsp;ds</span>)</p><div class="classdoc-comment-body"> Get the content-transfer-encoding that should be applied to the input
 stream of this datasource, to make it mailsafe.
 <p/>
 The algorithm used here is:
 <ul><li>If the primary type of this datasource is "text" and if all the bytes
 in its input stream are US-ASCII, then the encoding is "7bit". If more
 than half of the bytes are non-US-ASCII, then the encoding is "base64".
 If less than half of the bytes are non-US-ASCII, then the encoding is
 "quoted-printable".
 </li><li>If the primary type of this datasource is not "text", then if all the
 bytes of its input stream are US-ASCII, the encoding is "7bit". If
 there is even one non-US-ASCII character, the encoding is "base64".
</li></ul></div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">ds</span> - DataSource</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>the encoding.
This is either "7bit", "quoted-printable" or "base64"</dt></dl><hr/><a name="javaCharset(String)"/><h3>javaCharset</h3><p class="prototype">public static String <b>javaCharset</b>(<span class="parameter">String&nbsp;charset</span>)</p><div class="classdoc-comment-body"> Convert a MIME charset name into a valid Java charset name.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">charset</span> - the MIME charset name</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>the Java charset equivalent.
If a suitable mapping is not available, the passed in charset is 
itself returned.</dt></dl><hr/><a name="mimeCharset(String)"/><h3>mimeCharset</h3><p class="prototype">public static String <b>mimeCharset</b>(<span class="parameter">String&nbsp;charset</span>)</p><div class="classdoc-comment-body"> Convert a java charset into its MIME charset name.
 <p/>
 Note that a future version of JDK (post 1.2) might provide this
 functionality, in which case, we may deprecate this method then.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">charset</span> - the JDK charset</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>the MIME/IANA equivalent.
If a mapping is not possible, the passed in charset itself is returned.</dt></dl><hr/><a name="quote(String,String)"/><h3>quote</h3><p class="prototype">public static String <b>quote</b>(<span class="parameter">String&nbsp;text,</span> <span class="parameter">String&nbsp;specials</span>)</p><div class="classdoc-comment-body"> A utility method to quote a word, if the word contains any characters 
 from the specified 'specials' list.
 <p/>
 The HeaderTokenizer class defines two special sets of delimiters - 
 MIME and RFC 822.
 <p/>
 This method is typically used during the generation of RFC 822 and MIME
 header fields.
</div><p/><div class="classdoc-tag-section-header">Parameters:</div><dl class="classdoc-list"><dt><span class="prototype-name">text</span> - word to be quoted</dt><dt><span class="prototype-name">specials</span> - the set of special characters</dt></dl><div class="classdoc-tag-section-header">Returns:</div><dl class="classdoc-list"><dt>the possibly quoted word</dt></dl><hr class="footer"/><div class="footer">Generated on
  October 6, 2004
  by <a target="cptoolsinfo" href="http://www.gnu.org/software/cp-tools">GNU Classpath Tools</a> (Gjdoc XmlDoclet 0.6.1).</div></body></html>